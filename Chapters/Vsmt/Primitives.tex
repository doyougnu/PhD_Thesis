~\label{section:vsmt:primitives}
%
In order to construct a variational \ac{smt} solver we must first extend
\ac{vpl} to include non-Boolean values. \ac{vpl} included two kinds of
relations: relations such as $\neg$ and $\vee$ which required accumulation in
the context of variation, and relations such as $\wedge$ which required no
special handling due to variation. All \ac{smt} theories except arrays are
directly expressible with accumulation because they form a context-free grammar.
Thus, to extend \ac{vpl} to \evpl{}, we need only to add the appropriate cases
to the syntax, and add the requisite primitive operations which are supported by
any \acl{smtlib} compliant solver.

The \evpl{} syntax is presented in \autoref{fig:arith:stx}. \evpl{} includes
syntax of the integer arithmetic extension, which consists of integer variables,
integer literals, a set of standard operators, and choices.
%
The sets of Boolean and arithmetic variables are disjoint, thus an expression
such as $(\kf{s < 10) \wedge (s \vee p})$, where $s$ occurs as both an integer
and Boolean variable is disallowed.
%
The syntax of the language prevents type errors and expressions that do not
yield Boolean values. For example, $\chc[D]{1,2} \wedge p$ is syntactically
invalid.
%
Thus, the language is purposefully limited to arithmetic expressions that
have an inequality at the root of the expression, such as: $\kf{g} =
(\chc[A]{1, 2} + j \geq 2) \vee a \wedge \chc[A]{c, d}$.
%
Choices in the same dimension are synchronized across Boolean and arithmetic
sub-expressions, for example, the expression
%
$\kf{g} = (\chc[A]{1, 2} + j \geq 2) \vee (a \wedge \chc[A]{c,d})$
% %
represents two variants:
%
$\sem[\{(A, \true)\}]{g} = (1 + j \geq 2) \vee (a \wedge c)$ and
$\sem[\{(A, \false)\}]{g} = (2 + j \geq 2) \vee (a \wedge d)$.

\begin{figure}
  \input{Figures/Vsmt_Rules_PrimOps}
  \caption{Assumed base solver primitive operations}%
  \label{fig:vsmt:inf:prim}
\end{figure}


%%% Local Variables:
%%% mode: latex
%%% TeX-master: "../../thesis"
%%% End: