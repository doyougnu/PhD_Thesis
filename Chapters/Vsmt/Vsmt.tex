~\label{chapter:vsmt}
%
In this chapter we describe an extension of variational satisfiability solving
to variational \ac{smt} solving.
% %
\ac{smt} solvers generalize \ac{sat} solvers through the use of \emph{background
  theories} that allow the solver to reason about values and constructs outside
the Boolean domain. The SMTLIB2 standard defines seven such background theories:
\rn{Core} (Boolean theory), \rn{ArraysEx}, \rn{FixedSizeBitVectors},
\rn{FloatingPoint}, \rn{Ints}, \rn{Reals}, and \rn{Real\_Ints}. In this chapter,
we use integer arithmetic (\rn{Ints}) as an example \ac{smt} extension for
variational \ac{smt} solving. Extensions for other background theories are
similar to the \rn{Ints} extension with the exception of the array theory. The
array theory presents unique challenges due to interactions with choices; we
conclude the section by presenting the array extension thus recovering the most
popular \ac{smt} background theories in the variational solver.
% %

\begin{figure}
  \centering
  \input{Figures/Vsmt_Syntax}
  \caption{Syntax of Integer arithmetic extension.}%
  \label{fig:arith:stx}
\end{figure}
%
\begin{figure}
\input{Figures/Vsmt_Vpl_Syntax}
\centering
\caption{Syntax of extended \ac{vpl}.}%
\label{fig:arith:vpl}
\end{figure}

\section{\ac{vpl} extensions and primitives}
\input{Chapters/Vsmt/Primitives}

\section{Semantics}
%
\autoref{fig:vsmt:inf:prim} shows a set of primitive operations that the base
solver is assumed to support. We use the nonterminals in the grammar as
metavariables to range over operations. The naming scheme of the metavariables
is to use \uop{}, \bop{}, and \sop{} to indicate unary, binary, and solver
functions in the base solver domain, and use subscripts to indicate the
argument type and (in the case of binary operations) result type of the
operations they range over.
%
For example, integer inequality is ranged over by \bib{}, indicating that
inequality is a binary function whose arguments are of type \integers{} and
whose result is of type \booleans{}.
% When a result is the same type as the arguments we elide the result
% subscript, such as in Boolean and Integer negation, and
%
We do not show subscripts for \sop{} as these operations are run for their side
effects in the base solver.
%
\itodo{not sure if this is a good strategy, we would have to show models and a
unit value for side effects if we didn't elide these though}.

\itodo{also not sure about the unary symbol, but I think making the
  variational level all symbols and using text for base solver level is a good
  idea, open to suggestions here}
%
\eric{Can we define these directly in the grammar in Fig.~6? I think this is
confusing and overwhelming in its current form.}
%
Similarly we define metavariables for these
functions in the variational \ac{smt} domain. We use \inequalities{} to
represent binary relations over integers, \integerFuncs{} to represent
arithmetic binary functions such as addition, \integerUnary{} for unary
arithmetic functions, and \boolFuncs{} to represent binary logical connectives.
Thus a term such as $\kf{(i < j) \wedge a}$ is represented as
$\kf{\bbb{}(\bib{}(i,j),a)}$ in the base solver domain, and $(i \inequalities{}
j) \boolFuncs{} a$ in the variational \ac{smt} solver domain.

\subsection{Accumulation}
\input{Chapters/Vsmt/Accumulation}

\subsection{Evaluation}
\input{Chapters/Vsmt/Evaluation}

\subsection{Choice removal}
\input{Chapters/Vsmt/ChoiceRemoval}

\section{Example derivation and solving of a Variational Core}
\input{Chapters/Vsmt/Example}

\section{Variational \ac{smt} models}
\input{Chapters/Vsmt/Models}

%%% Local Variables:
%%% mode: latex
%%% TeX-master: "../../thesis"
%%% End:
