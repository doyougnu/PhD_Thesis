~\label{section:vsmt:example}
%
With variational \ac{smt} solving formally specified. We present a complete
example of solving a variational \ac{smt} problem. Consider the query formula
\newline$\kf{\hV = ((1 + 2 < (i - \chc[A]{k,l})) \wedge a) \wedge
  (\chc[B]{c,\neg b} \vee b)}$ with two choices parameterized by the dimensions
$A$ and $B$. Derivation of the variational core for $\kf{h}$ begins with all
evaluation and all stores \aStore{}, \eStore{} initialized to $\emptyset$.

The root of \hV{} is $\wedge$ and thus \evAnd{} is the only applicable rule.
From \evAnd{} we have $\eIL*{1} = \kf{((1 + 2 < (i - \chc[A]{k,l})) \wedge a)}$,
and $\eIL*{2} = (\chc[B]{c,\neg b} \vee b)$. We traverse \eIL*{1} first, leading
to a recursive application of \evAnd{}. We denote recursive levels with a tick
mark: $'$, thus $\kf{\eIL*{1}' = (1 + 2 < (i - \chc[A]{k,l}))}$ is the left
child of \eIL*{1}, with $\kf{\eIL*{2}' = a}$ as the right child.

The root of $\eIL*{1}'$ is an inequality, so the only way to progress is to try
to accumulate $\eIL*{1}'$. The accumulation will succeed; in accumulation, only
\acInEqV{} can apply as accumulation will be unable to transform the right child
of $\eIL*{1}'$ to a symbolic value due to the presence of a choice. \acInEqV{}
will further destruct $\eIL*{1}'$ to $\eAR*{1} = 1 + 2$ and $\eAR*{2} = i -
\chc[A]{k,l}$. $\eAR*{1}$ will be accumulated to a single symbolic value by
application of \acArithS{} and \acRef{} on the literals $1$ and $2$ yielding
$\eAR*{1} = s_{12}$, with store $\aStore{}=\set{(s_{1} + s_{2}, s_{12}),
  (2,s_{2}), (1,s_{1})}$.

Using the resultant store from accumulating $\eAR*{1}$, accumulation on
$\eAR*{2}$ will yield the term $s_{i} - \chc[A]{k,l}$. The variable $i$ will be
accumulated to a symbolic value with \acRef{} and the choice will be passed over
by \acChc{}. Thus we have the accumulated result for $\eIL*{1}'$ as the
intermediate term $\eIL*{1}_{acc} = s_{12} < (s_{i} - \chc[A]{k,l})$ with store
$\aStore{}=\set{(i, s_{i}),(s_{1} + s_{2}, s_{12}), (2,s_{2}), (1,s_{1})}$.

With the left child of $\eIL*{1}'$ accumulated, \evAnd{} attempts to continue
evaluation on the right child and will succeed. Notice that this is a special
case as the root of \eIL*{1} is $\wedge$ and so is the root of \hV{}. Thus,
$\eIL*{2}$ will transform $a$ to a symbolic value through accumulation using the
previous store and assert the symbolic value in the base solver with \evSym{}.
The resulting intermediate term will be $s_{12} < (s_{i} - \chc[A]{k,l}) \wedge
\unit{}$, with stores $\eStore{}=\set{s_{a}}$, $\aStore{}=\set{(a,s_{a}),(i,
  s_{i}),(s_{1} + s_{2}, s_{12}), (2,s_{2}), (1,s_{1})}$ and will be reduce to
the final intermediate result $\eIL*{1}_{core} = s_{12} < (s_{i} -
\chc[A]{k,l})$ with the same stores via application of \evAndR{}.

We have now returned back to the top level call to \evAnd{} with a result for
the left child and populated stores. Evaluation will proceed on the right child
$\eIL*{2}$. \eIL*{2}'s root is a disjunction, and thus to proceed evaluation
switched to accumulation by applying \evAcc{}. The accumulation is
straightforward; the left child is the choice $\chc[B]{c, \neg b}$ and is
returned by \acChc{}. The right child is a single variable, and thus is
translated to the symbolic value $s_{b}$. Thus we have the final result for
$\eIL*{2}$, $\eIL*{2}_{core} = \chc[B]{c,\neg b} \vee{} s_{b}$ and the
variational core of \hV{}, $\hV{}_{core} = s_{12} < (s_{i} - \chc[A]{k,l})
\wedge{} (\chc[B]{c,\neg b} \vee{} s_{b})$ with stores $\eStore{}=\set{s_{a}}$,
$\aStore{}=\set{(b, s_{b}),(a,s_{a}),(i, s_{i}),(s_{1} + s_{2}, s_{12}),
  (2,s_{2}), (1,s_{1})}$.

With the variational core derived we can begin choice removal. We assume an
empty configuration for the remainder of the example. The exact semantics of a
\vc{} is implementation specific. For example, our prototype variational
\ac{sat} solver pre-populates the configuration with a generated configuration
based on the user \vc{}. In contrast, the prototype variational \ac{smt} solver
checks the dimensions assignments of \true{} or \false{} in \crChc{} are valid
with respect to the \vc{}, if not then the variant is skipped.

Choice removal begins with the variational core in the focus and an evaluation
context \zipper{} = \inRoot{}, because $\hV_{core}$'s root is $\wedge$ only
\crBool{} applies moving $s_{12} < (s_{i} - \chc[A]{k,l})$ into the focus and
storing the right child in the context: $\zipper =
\inBoolL*{\inRoot{}}{(\chc[B]{c,\neg b} \vee{} s_{b})}{\wedge}$. With $s_{12} <
(s_{i} - \chc[A]{k,l})$ as the focus, the only applicable rule is \crInEq{} due
to $<$ at the root of the focus. \crInEq{} again recurs left, focusing on the
sub-term $s_{12}$ with context $\zipper =
\inInEqL*{\inBoolL*{\inRoot{}}{(\chc[B]{c,\neg b} \vee{} s_{b})}{\wedge}}{(s_{i}
  - \chc[A]{k,l})}{<}$ which states that $s_{12}$ exists in the left child of an
inequality which also exists in the left child of a conjunction.

We have arrived at a base case, where a symbolic value is in focus, and the
immediate parent in the evaluation context is an inequality. To proceed we need
to \emph{switch} to begin processing the right child of the inequality; thus we
must apply \crInEqL{}. \crInEqL{} swaps the symbolic with the un-processed right
child held in the context, hence we have $(s_{i} - \chc[A]{k,l})$ in focus with
context $\zipper = \inInEqR*{s_{12}}{\inBoolL*{\inRoot{}}{(\chc[B]{c,\neg b} \vee{}
    s_{b})}{\wedge}}{<}$. 


%%% Local Variables:
%%% mode: latex
%%% TeX-master: "../../thesis"
%%% End: