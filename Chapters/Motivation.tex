~\label{sec:introduction}

%% get to the problem:
%%% incremental satisfiability solvers solve sets of related problems efficiently
%%% but the interface could be improved in two ways
%%% first the interface require hand programming the solver, leading to
%%% brittle solutions
%%% secondly, the specifies control flow operations that dictate runtime
%%% behavior, thus any static optimizations enabled by domain knowledge cannot
%%% be used.

Classic \ac{sat}, which solves the boolean satisfiability
problem~\cite{10.5555/1550723} has been one of the largest success stories in
computer science over the last two decades. Although \ac{sat} solving is known
to be NP-complete~\cite{10.1145/800157.805047}, \ac{sat} solvers based on
\ac{cdcl}~\cite{Marques-Silva:1999:GSA:304491.304506,Silva:1997:GNS:244522.244560,10.5555/1867406.1867438}
have been able to solve boolean formulae with millions variables quickly enough
for use in real-world applications~\cite{10.5555/1557461}. Leading to their
proliferation into several fields of scientific inquiry ranging from software
engineering to
Bioinformatics~\cite{10.1007/11814948_16,10.1007/978-3-642-31612-8_12}.

However, the majority of research in the \ac{sat} community focuses on solving a
single \ac{sat} problem as fast as possible, yet many practical applications of
\ac{sat}
solvers~\cite{silva1997robust,10.1007/3-540-44798-9_4,10.1145/378239.379019,10.1145/1698759.1698762,Een_asingle-instance,een2003temporal,10.5555/1998496.1998520}
require solving a set of related \ac{sat}
problems~\cite{10.1007/3-540-44798-9_4, silva1997robust, een2003temporal}. To
take just one example, \ac{spl} utilizes \ac{sat} solvers for a diverse range of
analyses including: automated feature model
analysis~\cite{useBTRC05,GBT+19,TAK+:CSUR14}, feature model
sampling~\cite{MKR+:ICSE16,VAT+:SPLC18}, anomaly
detection~\cite{AKTS:FOSD16,KAT:TR16,MNS+:SPLC17}, and dead code
analysis~\cite{TLSS:EuroSys11}.

The misalignment the \ac{sat} research community and the practical use cases of
\ac{sat} solvers is well known. To address the gap, modern solvers attempt to
propagate information from one solving instance, on one problem, to future
instances in the problem set. Initial attempts focused on
\ac{cs}~\cite{10.1007/3-540-44798-9_4,10.1145/378239.379019} where learned
clauses from one problem in the problem set are propagated forward to future
problems. Modern solvers are based on a major breakthrough that occurred with
\emph{incremental \ac{sat} under assumptions}, introduced in
Minisat~\cite{10.1007/978-3-540-24605-3_37}.

Incremental \ac{sat} under assumptions, made two major contributions: a
performance contribution, where several pieces of information including learned
clauses, restart and clause-detection heuristics are carried forward. A
usability contribution; Minisat exposed an interface which allowed the end-user
to directly program the solver. Through the interface the user can add or remove
clauses and dictate which clauses or variables are shared and which are unique
in the problem set.

Despite the success of incremental \ac{sat}, the incremental interface can be
improved in two ways: First, by requiring the user to direct the solver, the
users' solution is specific to the exact set of satisfiability problems at hand,
thus the programmed solution is specific to the problem set and therefore to the
solver input. Second, should the user be interested in the assignment of
variables under which the problem at hand was found to be satisfiable, then the
user must create additional infrastructure to track results; which again couples
to the input and is therefore difficult to reuse.

In this thesis, I hypothesize usability and performance improvements to
incremental \ac{sat} are possible by applying recent work on \emph{variation},
and \emph{variational
  programming}~\cite{EW11gttse,EW11tosem,HW16fosd,CEW16ecoop,Walk14onward},
which defines a theory of variation and formalizes a language to expresses
variation called the \emph{choice calculus}. With the choice calculus, the
aforementioned set of problems is able to be expressed statically as a
\emph{variational artifact}. With this representation, the interface to
incremental solving can be automated through a \emph{variational interpreter},
furthermore by identifying and isolating the variational nature in incremental
solvers, optimizations derived from the choice calculus become possible.

The goal of my research is to explore the design space and architecture of a
\emph{variational satisfiability solver} that uses research on variation in the
context of incremental \ac{sat} solving. The rest of this section expands on
these claims. \autoref{sec:prop-contr} lists the specific contributions this
thesis will make and outlines the rest of this document.

\subsection{Proposed Contributions}%
\label{sec:prop-contr}
The high-level goal of my research is to formalize and construct a variational
satisfiability solver that understands and can solve \ac{sat} problems that
contain \emph{variational values} in addition to boolean values. In pursuit of
this goal, my thesis will make the following contributions, items which are
complete at time of this writing are indicated with a \checkmark:
\begin{enumerate}
\item\label{vpl-deliverable} \emph{Variational propositional logic}: \ac{sat}
  solvers input and operate on sentences in propositional
  logic\cite{10.5555/1324777}. Variational satisfiability solvers, in order to
  reason about variation, must input sentences in a propositional logic that is
  \textit{variational}, \ie{} a many-valued logic~\cite{Rescher1969-RESML} which
  contains variational values, called \emph{choices} in addition to boolean
  values.

  The formulation of \ac{vpl} is requisite and central to the high level goal of
  designing a variational satisfiability solver. Furthermore, \ac{vpl} serves
  two other functions: It provides an avenue for future work through the
  formalization of variation in the domain of propositional logic for
  variational satisfiability solvers. It provides a foundation for research on
  variation in propositional logic outside of the considerations of
  satisfiability solvers.

  This work is nearly complete. The logic has been formalized and successfully
  used in a prototype variational solver\cite{10.1145/3382025.3414965}.
  \autoref{sec:vpl} introduces \ac{vpl} and describes the following
  contributions which are directly enabled by it:

  \begin{enumerate}
  \item \checkmark{} A set of variation preserving equivalences. Similar to the well known
    propositional logic equivalences, such as DeMorgan's law, these equivalences
    allow a variational solver to refactor input possibly yielding simpler
    variational sentences.
  \item\label{encoding-strat-deliverable} An efficient algorithm for translating
    a set of propositional formulae into a single \ac{vpl} formula. The
    prototype variational \ac{sat} solver used a naive algorithm, and
    preliminary results showed that the encoding impacts solver performance.
    Hence, finding a more efficient encoding algorithm is desirable. This work
    is yet to be done but there are two promising routes forward. First, a naive
    algorithm which interleaves syntactic equivalences to produce a \ac{vpl}
    formula that is easier to solve. Second, an algorithm similar to Huffman
    codes\cite{4051119} to translate the \ac{sat} problems into a data
    structure, then use heuristics to select high quality candidates to combine.
    With such an algorithm the end-user of the variational solver only needs to
    input their problem sequence rather than a \ac{vpl} formula.
  \end{enumerate}

\item\label{vsat-deliverable} \emph{A variational satisfiability solver}: This
  is the central contribution of my thesis. It is completed and is published in
  a peer-reviewed conference~\cite{10.1145/3382025.3414965} paper. Preliminary
  results are promising but based on only two case studies from the \ac{spl}
  community.

  \autoref{sec:vsat} discusses these results and provides an overview of the
  variational solving algorithm. The following contributions are based on this
  work:
  \begin{enumerate}
  \item \checkmark{} Formalization of a variational \ac{sat} solving algorithm
    that inputs a \ac{vpl} formula and outputs a \emph{variational model}.
  \item \checkmark{} Formalization of variational models; that is satisfying
    assignments of values to variables in input formula that succinctly
    represent results in the context of variation.
  \item \checkmark{} A method for determining the amount of variation in a given
    \ac{vpl} formula.
  \item\label{phase-change-deliverable} A method for determining the relative
    hardness of a \ac{vpl} formula based on work in the random-\ac{sat}
    community~\cite{Gent94thesat}. This item is orthogonal to all other items
    and thus can be done in parallel.
  \end{enumerate}

\item\label{vsmt-deliverable} \emph{A concurrent variational \ac{smt} solver}:
  Contingent on \autoref{vsat-deliverable}, \emph{satisfiability modulo
    theories} extends \ac{sat} solvers such that they are able to reason about
  logical formulas in combination to \textit{background theories}, such as
  arithmetic or arrays. Furthermore, with variation statically represented in a
  \ac{vpl} formula, the \ac{sat} or \ac{smt} procedure can be made asynchronous
  leading to speedups on multi-core machines. The approach is to change the
  semantics of a choice; in the prototype \ac{sat} solver each choice blocks
  future \ac{sat} problems from being solved, by creating an asynchronous
  solving algorithm these future problems are unblocked and can be processed
  earlier.

  This item is an extension of the central contributions of the thesis. There
  are two extensions to the previous work to construct a variational \ac{smt}
  solver and one to make it asynchronous.

  First, the extensions to \ac{vpl} abstract logical connectives in \ac{vpl}
  allowing for theories which conclude to a Boolean value, such as arithmetic
  inequalities, and thus can be reasoned about in a \ac{smt} solver. Second,
  variational models are similarly extended, rather than assuming only Boolean
  values, the extension allows for polymorphic results through the use of
  SMTLIB2 compliant functions.

  Third, I extend the semantics of choices in the variational \ac{sat} solver to
  include atomic concurrent operations. When a choice is observed the solver
  state is copied and sent to a thread with instructions to compute continue the
  computation.

  This work is completed but unpublished. \autoref{sec:vsmt} expands on this
  item and discusses the evaluation of the prototype variational \ac{smt} solver
  with additional case studies. The following summarizes the expected
  contributions:
  \begin{enumerate}
  \item \checkmark{} Formalize the extension of \ac{vpl} with \ac{smt} theories.
  \item \checkmark{} Formalize the extension of variational models to express
    \ac{smt} results.
  \item \checkmark{} Formalize the asynchronous variational solving algorithm
  \item\label{nanopass-deliverable} A set of optimizations based on work on
    nanopass compilers~\cite{10.1145/2500365.2500618} from the scheme
    programming language community~\cite{r7rs-scheme}. The goal is to leverage
    \ac{vpl} equivalence rules and other compiler optimizations, such as
    inlining, on SMTLIB2 programs, thus optimizing variational SMT programs. The
    prototype variational \ac{smt} solver is architected as a nanopass compiler
    and thus is able to perform optimizations as a single pass over the input
    formula. However, no optimizations are performed as of yet, although all
    requisite items for this work to begin are done.
  \item \label{eval-deliverable}An empirical evaluation of solver performance. The empirical evaluation
    will reuse the datasets the prototype \ac{sat} solver was evaluated on. In
    addition, three new data sets will be added, two by harvesting \ac{sat}
    problems from work on variational lexing, parsing, and type
    checking~\cite{KKHL:FOSD10} real world software such as
    Busybox~\cite{busybox} and the Linux kernel~\cite{linux}, and one by
    generating variational \ac{smt} problems. This dataset will be used several
    times in the thesis and will be made public. First, as a foundation to test
    the encoding strategies from \autoref{encoding-strat-deliverable}. Second,
    to evaluation the optimizations from \autoref{nanopass-deliverable} and
    third, to evaluate the performance of the single threaded and multi-threaded
    variational \ac{smt} solver. This work is partially complete, random
    generation of variational \ac{sat} and \ac{smt} problems is done, as is the
    Busybox dataset. The remaining work is to scale the logging solution to
    handle the Linux kernel.
  \end{enumerate}

\item \label{proof-deliverable} \textit{Proof of variation preservation}: A
  proof of variation preservation is a proof that the results of the variational
  solvers are sound, \ie{}, for any variant $\kf{v}$, if a variational solver
  finds $\kf{VSat(v)} = \kf{True}$, then $\kf{Sat(v)} = \kf{True}$. Both
  \autoref{vsat-deliverable} and \autoref{vsmt-deliverable} are verified sound
  via property-based testing~\cite{10.1145/351240.351266} but the variational
  solving algorithm itself has not been proven sound up to the soundness of the
  underlying incremental solver. This work is in progress using the proof
  assistant Agda\cite{10.1145/2841316} and is expected to yield such a proof.
  \autoref{sec:vsmt} discusses this item further and lists the specific tasks
  left to do.
\end{enumerate}

\subsection{Significance and Potential Impact}%
\label{sec:sign-potent-impact}
The goal of this thesis is to explore the design and architecture of a
variational satisfiability solver. The solver should allow end-users to input a
set of propositional formulae and output a model that is useful \emph{without}
requiring the end-user to understand or be aware of research on variation.

This work is applied programming language theory in the domain of satisfiability
solvers. Many analyses in the software product-lines community use incremental
\ac{sat} solvers. By creating a variational \ac{sat} solver it is likely that
such analyses would directly benefit from this work, and thus advance the state
of the art.

For researchers in the incremental satisfiability solving community, this work
serves as an avenue to construct new incremental \ac{sat} solvers which
efficiently solve classes of problems that deal with variation, by exploiting
results from the programming language community.

For researchers studying variation the significance and impact is several fold.
By utilizing results in variational research, this work adds validity to
variational theory and serves as an empirical case study. At the time of this
writing, and to my knowledge, this work is the first to directly use results in
the variational research community to parallelize a variation unaware tool. Thus
by directly handling variation, this work demonstrates possible benefits, such
as parallelism, researchers in other domains may attain and thereby magnifies
the impact of any results produced by the variational research community.
Furthermore, the result of my thesis, a variational \ac{sat} solver, provides a
new logic and tool to reason about variation itself.

For researchers in other domains, a requisite result in constructing a
variational satisfiability solver is a variational compiler; which translates
\ac{vpl} to a solver-domain programming language. Thus, while my thesis is
focused on the domain of \ac{sat} solvers, this work describes a first of its
kind variational compiler whose architecture may be reused to create new
variation-aware tools such as build systems or programming languages. Such
compilers could directly benefit from \autoref{nanopass-deliverable} as this
item describes performance improvements that \emph{are only possible} with an
explicit and static representation of variation.

%%% Local Variables:
%%% mode: latex
%%% TeX-master: "../thesis"
%%% End: