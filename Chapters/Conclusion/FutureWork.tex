\label{section:conclusion:future-work}

There are numerous avenues of future work ranging from novel applications, to
refining the implementations, to extended the solvers with new features. In this
section we collect and discuss the most promising future work.

\subsection{Utilization of variational cores}
Variational cores are an important and foundational concept for the variational
solver's and consequently for the variationalization recipe. Recall that the
purpose of variational cores was twofold: First, to condense the query formula
such that the variational terms were the majority of terms core. Second, to
simplify the choice removal process by reducing the amount of traversal required
to process the choices. Third, to enforce sharing between variants as the
contexts captured by the core were are reused during choice removal.

This last point is key, because variational cores in combination with the
accumulation and evaluation stores, completely capture the context of a formula
they can be reused in novel ways. For example, one might serialize a variational
core and associated stores to disk, thus effectively caching the core for future
use. Such a feature would enable desirable user facing effects: the solver could
restart without losing information and thus might be useful for debugging or
exploration, if the variational cores require a lot of processing time to
generate this time be amortized, or if the application domain only builds on
previous versions of the same formulas, then the variational core could be
reused.

For example, consider the case of a feature model which evolves every month for
several months, similarly to the \fin{} and \auto{} datasets. Since the feature
model, and consequently the \ac{vpl} formula evolves over time, the previous
variational core could be modified to reflect the changes for the new formula.
Adding new constraints is straightforward; one would simply nest the previous
variational core in a conjunction context with the new core and reuse the
previous stores when generating the new core to ensure sharing. A more difficult
problem is removing constraints or variables in the previous core. Both removing
constraints and removing variables is problematic as the variable or constraint
could have been accumulated into a symbol value or several symbolic values. One
could traverse a dependency graph to find all references of the variable and
symbolic value, and then seek to replace those references with a unit value,
such as \tru{} for $\wedge$ or \fls{} for $\vee$. However this immediately leads
to the problematic case where the variable or symbolic to be removed is in a
$\neg$ context. There is no unit value where $\neg$ does not have meaning and
thus we cannot remove arbitrary variables from a variational core.

In addition to manipulating or storing variational cores, future variational
solvers might utilize them as a convenient messaging format. Throughout this
thesis, we have assumed and have only considered systems which process all
variants in a single base solver instance, however this need not be the case.
Instead, when a choice in is the focus of a the evaluation context (and thus the
variational core) one might choose to solve the true alternative variants in a
different solver and all the false alternatives in the same solver. For example,
a user might know that all true alternative variants have particularly good
performance characteristics for boolector, while all false variants have good
characteristics for yices. Since we compile to \acl{smtlib} script such a
feature is possible with few changes to our method of variational solving. To
add such a feature a future variational solver would allow the user to select
particular solvers over the input \vc{} or the configuration for a query
formula.

\subsection{Further \ac{smt} background theories and tool extensions}
\ac{sat} and \ac{smt} solvers are attractive targets for research on variational
languages. As of this writing, designing a language with variational
side-effects is an open research question. The essential problem is tracking
effects for particular variants across the interface between a variational-aware
system and a plain system. For example, imagine writing a file to disk in one
variant and deleting a different file in another variant. Since the file system
has no concept of variation or variant the variational system is not able to
guarantee variants are isolated and therefore variants may interact in
undesirable and difficult to predict ways. \ac{sat} and \ac{smt} solvers side
step this limitation as they are side-effect free systems. There is simply no
way to read a file disc in an \acl{smtlib} script. Similarly, classes of
run-time errors are not possible. For example, consider an \acl{smtlib} script
which divides by zero, in this case the script simplify will not unify and an
\rn{unsat} will be returned.

Due to the attractive properties of \ac{sat} and \ac{smt} solvers for
variational research, a straightforward avenue of future work is to continue to
investigate efficient variational folds by further extending the variational
solvers. Modern \ac{sat} and \ac{smt} solvers allow quantified constraints
following first-order logic. In this thesis, we have only considered
unquantified constraints, and thus the interaction of between quantified
constraints and choices is an open research problem.

Similarly, we have demonstrated extensions for core background theories, but
there are many features of plain solvers that would be desirable additions to
variational solvers. Such features include generation of variational
unsatisfiable-cores. An unsatisfiable core is a subset of constraints that
prevent the \ac{sat} or \ac{smt} from unifying. Unsatisfiable cores are thus
desirable for many problems where discovering this information is desirable. For
example, one might desire to find the clique in a \ac{sat} encoded weighted
graph which prevents a traversal under some cost limit. Or one might desire to
find the sub-set of features in a feature model that prevent classes of products
from being built.

Enabling variational unsatisfiable cores is possible with our approach of
accumulation, evaluation and choice removal. The key requirement would be to
ensure that the plain, \rn{get-unsat-core} command occurs inside the
\rn{push}/\rn{pop} block for a given variant. Thus far we have only seen the
\rn{get-model} command have this property. Thus a straightforward approach would
be to create a syntactic category that contains arbitrary plain commands, such
as \rn{get-model} or \rn{get-unsat-core} to be sent to the base solver once a
variant has been reduced to \unit{}. Another approach is to create full fledged
variational \acl{smtlib} language instead of expressions of constraints as we
have presented here. Constructing such a variational \acl{smtlib} language is
likely to save work for future extensions. The language would be identical to
\acl{smtlib} except that \rn{push}/\rn{pop} would not be exposed to the user (or
would only be enabled with an option), and choices would be included in the
language just as we have included the for \ac{vpl} and \evpl{}.


\subsection{Automatic construction of a \ac{vpl} formula}

\subsection{Abstracting the variationalization recipe to other domains}


%%% Local Variables:
%%% mode: latex
%%% TeX-master: "../../thesis"
%%% End: