~\label{section:conclusion:applications}
%
Software variability, as explored in this paper, is a natural application domain
for our work. The variability of SPLs or configurable software is often reduced
to propositional logic~\citep{B05,CW07,MWCC08} for analysis
purposes~\citep{BSRC10,TAK+:CSUR14,GBT+19}. Many analyses have been implemented
using \ac{sat} solving such as~\cite{TAK+:CSUR14}, including feature-model
analysis~\citep{BSRC10,GBT+19}, parsing~\citep{KGR+:OOPSLA11}, dead-code
analysis~\citep{TLSS:EuroSys11}, code simplification~\citep{RGA+:ICSE15}, type
checking~\citep{TBKC07}, consistency checking~\citep{CP06}, dataflow
analysis~\citep{LKA+:ESECFSE13}, model checking~\citep{CCS+13},
variability-aware execution~\citep{NKN:ICSE14}, testing~\citep{MMCA:IST14},
product sampling~\citep{MKR+:ICSE16,VAT+:SPLC18}, product
configuration~\citep{SIMA:ASE13}, optimization of non-functional
properties~\citep{SRK+:SQJ12}, and variant-preserving
refactoring~\citep{FMS+:SANER17}. While each of these analyses gives rise to
multiple \ac{sat} problems for even a single analysis run, the authors typically
do not discuss how they are solved. We argue that many could benefit from
variational solving.

More generally, any scenario that involves solving many related \ac{sat}
problems, and where all of these problems are known or can be generated in
advance, is a potential application for variational \ac{sat} solving.
%
Such situations arise in program analysis~\citep{VGD:FSE12}, and especially in
\emph{speculative} program analyses that involve generating and exploring huge
numbers of variations of a program, for example, as in
counterfactual~\citep{CE14popl} and migrational~\citep{CCW18icfp,CCEW18popl}
typing. Furthermore, we believe that variational solving could provide a basis
for similar speculative analyses on feature models.


%%% Local Variables:
%%% mode: latex
%%% TeX-master: "../../thesis"
%%% End: