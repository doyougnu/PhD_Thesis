\label{section:conclusion:cont-summary}

The main contribution of this work is the formalization of variational
satisfiability solver. In \autoref{chapter:introduction} we defined the success
of this thesis as applying the concept of variation in the domain of
satisfiability solving to create a variational satisfiability solver. The solver
must explicitly expresses the concept of variation in a user-facing language and
must be reasonably performent with respect to the performance of plain
satisfiability solvers. By this definition we have succeeded.\todo{make sure
  this was defined in intro}

In \autoref{chapter:vpl} we formalized a many-valued logic to express
variational \ac{sat} problems, demonstrated an application of the choice
calculus with propositional logic as the object language. We defined the
denotational semantics of configuration over the logic, and fundamental concepts
such as variants and synchronization.

In \autoref{chapter:vsat} we formalized our approach to variational
satisfiability solving based on this logic. Our approach is to variationalize
non-variational solvers by constructing a compiler to a standardized input
format. We saw that this approach has many desirable properties: The stages of
accumulation, evaluation, and choice removal cleanly separate concerns. The
sharing of plain terms is guaranteed between variants because we use a zipper to
capture evaluation contexts. Since our design integrates plain base solvers, our
variational solver can take advantage of advances made by the \ac{sat} and
\ac{smt} communities. Lastly, we proved that our design is confluent, thereby
showing that the variational solver is variation-preserving and thus sound.

In \autoref{chapter:vsmt} we extended the architecture to handle non-Boolean
constraints. We saw that extensions over the term language follow a pattern: One
wraps the primitive base solver operations to handle symbolic values, then
defines a congruence rule to process the recur on the left child of the
relation, and finally defines a computation rule that calls the wrapped
primitive to combine two symbolic values thereby producing a fold over the
relation. We presented two extensions; one over integer constraints, and one
over array based constraints. Since, symbolic values are untyped, we carefully
constructed the extended logic to make type errors inexpressible, we could have
otherwise chose to employ a simple type system as the \acl{smtlib} standard
does. Lastly, we saw that this extension pattern works even for background
theories that seem difficult, because our architecture processes plain terms
before variational terms due to the ordering between accumulation and choice
removal.

In \autoref{chapter:case-studies}, we built two prototype variational solvers
called \vsat{} and \vsmt{}. We evaluated the solvers over two real-world
datasets. We observed that variational solving does produce speedups over
standard use of an incremental solver when solving many variants. The
variational solvers produce this performance speedup by reusing shared terms and
avoiding redundant computation. We also observed that the base solver does have
an impact on runtime performance. Therefore an advantage of our method is that
it is base solver agnostic, and thus implementations can choose whichever
\acl{smtlib} solver is performent for its problem domain. However, we found that
outside of its use case---when solving only a single variant---variational
solving did show a performance overhead that was statistically significant for
one dataset. Lastly, our finding that the sharing ratio is positively correlated
to runtime performance repeats similar findings in the variational literature.
