~\label{section:sat-solving}

This section provides assumes knowledge of propositional logic, and provides
background to \acl{sat} and \ac{smtlib}; the standardized language for
interacting with \ac{sat} solvers. Following the notation from the many-valued
logic community~\cite{Rescher1969-RESML} we refer to propositional logic as
\pl{}, which denotes a two-valued logic.

A satisfiability solver is a software system that solves the Boolean
Satisfiability Problem. One of the oldest problems in computer
science\footnote{see~\citet{BBH+09} for a complete history from the ancients,
  through to George Boole to the modern day.} and famously
NP-complete~\cite{10.1145/800157.805047}, the Boolean satisfiability problem is
the problem of determining if a formula (sometimes called a sentence) in
propositional logic has an assignment of Boolean values to variables, such that
under substitution the formula evaluates to \tru{}. We formalize the problem and
terms in the following definitions:

\begin{definition}[Model]
  Given a formula in propositional logic: $\kf{f} \in \pl{}$, which contains a
  set of Boolean variables $\kf{vs}$. A model, $\kf{m}$, is a set of assignments
  of Boolean values to variables in $\kf{f}$ such that $\kf{f}$ evaluates to
  \tru{}, \ie{}, $\kf{m = \{ (v \assign b)\ |\ v \in vs, b \in \booleans} \}$.
\end{definition}

\begin{definition}[Satisfiable]
  \todo{add validity}Given a formula in propositional logic, $\kf{f}$, which
  contains a set of Boolean variables $vs$. If there exists an assignment of
  variables to Boolean values such that $\kf{f}$ evaluates to \tru{}, then we
  say $\kf{f}$ is \emph{satisfiable}.
\end{definition}

For example, we can show that the formula $\kf{good = (a \wedge b) \vee c}$ is
satisfiable with the model: $\{\kf{(a \assign{} \tru{}), (b \assign{} \tru{}),
  (c \assign{} \fls{})}\}$, because $(\tru{} \wedge{} \tru{}) \vee{} \fls{}$
results in \tru{}. However, a formula such as $\kf{bad = (a \vee b) \wedge
  \fls{}}$ is not satisfiable as no assignment of \fls{} or \tru{} to the
variables $\kf{a}$ and $\kf{b}$ would allow $\kf{bad}$ to evaluate to \tru{}.
With the preliminaries concepts we can now define the Boolean Satisfiability
Problem:

\begin{definition}[Boolean Satisfiability Problem]
  Given a formula in propositional logic, $\kf{f}$, determine if $\kf{f}$ is
  satisfiable.
\end{definition}

While the formal definition of the Boolean Satisfiability Problem requires a
formula in propositional logic, expressing the \ac{sat} problem in propositional
logic can be cumbersome. Thus, modern satisfiability solvers programming
languages to express \ac{sat} problems, communicate the problems to other people
and dictate the problems to the solver. In recent years these programming
languages have coalesced into a single standard via an international initiative
called \acl{smtlib}.

The \acl{smtlib}~\cite{BarFT-SMTLIB} standard formalizes a set of programming
languages that define interactions with a \ac{sat} or \ac{smt} solver. The
standard defines four languages, of which only two are used throughout this
thesis: a \emph{term and formula} language; which defines a language for writing
defining variables, functions and formulas in propositional and first-order
logic. The \emph{command} language; which defines a programming language to
interact with the solver. The command language is used to add or remove formula,
query the solver for a model and other side-effectual interactions such as
printing output.

For the remainder of this section we provide informal examples intended for a
general audience and cover only the commands and concepts required for
subsequent sections of this thesis. For a full language specification please see
\citet{BarFT-SMTLIB}.

\todo{define a listing language for smtlib}Consider this \ac{smtlib} program
which verifies that demorgans' law holds:

\begin{lstlisting}[columns=flexible,keepspaces=true,language=SMTLIB]
  (declare-const a Bool) ;; variable declarations
  (declare-const b Bool)
  (define-fun demorgan () Bool  ;; define demorgans
  (= (and a b) (not (or (not a) (not b)))))
  (assert (not demorgan))       ;; add a constraint for not demorgans
  (check-sat)                   ;; check that the constraints are satisfied
\end{lstlisting}

A program in \ac{smtlib} is a sequence of \emph{commands} (called
\emph{statements} in the programming language literature) that interact with the
solver. For example, the above program consists of six commands. Internally a
compliant solver such as z3~\cite{10.1007/978-3-540-78800-3_24} maintains an
internal stack called the \emph{assertion stack} that tracks user provided
variable and formula declarations. The elements of the assertion stack are
called \emph{levels} and are sets of \emph{assertions}. An assertion is a
logical formula, a declaration of a \emph{sort}, such as \lstinling{Bool}, or a
definition of a function symbol. Thus, \lstinline{(declare-const a Bool)}


The \ac{smtlib} grammar is defined to make parsing as simple and as fast
as possible, and thus \todo{is this the right way to say this?}is defined around
\emph{s-expressions}~\cite{10.1145/367177.367199}.


For our purposes,
s-expressions are linked lists of symbols. The first element of the list is a
symbol which represents a function or binding form while the remaining symbols
are arguments to the first.  These declarations are called
\emph{assertions} An assertion For example, \lstinline{(and a b)} calls the
function \lstinline{and} to conjunct two symbols, \lstinline{a} and
\lstinline{b}, while \lstinline{(declare-const a Bool)} declares a variable
\lstinline{a} of \emph{sort} (or \emph{type}) \lstinline{Bool}. \ac{smtlib}
scripts are constructed out of \emph{terms}. A term is a variable symbol, a
function symbol, a binding form, or a built in operator for annotation.
Variables in \ac{smtlib}


%%% Local Variables:
%%% mode: latex
%%% TeX-master: "../../thesis"
%%% End:
