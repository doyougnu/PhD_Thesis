~\label{section:sat-solving}
%
This section provides assumes knowledge of propositional logic, and provides
background to \acl{sat} and \ac{smtlib}; the standardized language for
interacting with \ac{sat} solvers. Following the notation from the many-valued
logic community~\cite{Rescher1969-RESML} we refer to propositional logic as
\pl{}, which denotes a two-valued logic.

A satisfiability solver is a software system that solves the Boolean
Satisfiability Problem~\cite{russelNorvig}. One of the oldest problems in
computer science\footnote{see~\citet{BBH+09} for a complete history from the
  ancients, through to George Boole to the modern day.} and famously
NP-complete~\cite{10.1145/800157.805047}, the Boolean satisfiability problem is
the problem of determining if a formula (sometimes called a sentence) in
propositional logic has an assignment of Boolean values to variables, such that
under substitution the formula evaluates to \tru{}. We formalize the problem and
terms in the following definitions:

\begin{definition}[Model]
  Given a formula in propositional logic: $\kf{f} \in \pl{}$, which contains a
  set of Boolean variables $\kf{vs}$. A model, $\kf{m}$, is a set of assignments
  of Boolean values to variables in $\kf{f}$ such that $\kf{f}$ evaluates to
  \tru{}, \ie{}, $\kf{m = \{ (v \assign b)\ |\ v \in vs, b \in \booleans} \}$.
\end{definition}

\begin{corollary}[Validity]
  \todo{not sure if this is the right place}In propositional logic a formula or
  sentence is \emph{valid} if it is true in \emph{all} possible
  models~\cite{russelNorvig}. That is, a valid formula or sentence is also a
  tautology.
\end{corollary}

\begin{definition}[Satisfiable]
  Given a formula in propositional logic, $\kf{f}$, which contains a set of
  Boolean variables $vs$. If there exists an assignment of variables to Boolean
  values such that $\kf{f}$ evaluates to \tru{}, then we say $\kf{f}$ is
  \emph{satisfiable}.
\end{definition}

For example, we can show that the formula $\kf{good = (a \wedge b) \vee c}$ is
satisfiable with the model: $\{\kf{(a \assign{} \tru{}), (b \assign{} \tru{}),
  (c \assign{} \fls{})}\}$, because $(\tru{} \wedge{} \tru{}) \vee{} \fls{}$
results in \tru{}. However, a formula such as $\kf{bad = (a \vee b) \wedge
  \fls{}}$ is not satisfiable as no assignment of \fls{} or \tru{} to the
variables $\kf{a}$ and $\kf{b}$ would allow $\kf{bad}$ to evaluate to \tru{}.
With the preliminaries concepts we can now define the Boolean Satisfiability
Problem:

\begin{definition}[Boolean Satisfiability Problem]
  Given a formula in propositional logic, $\kf{f}$, determine if $\kf{f}$ is
  satisfiable.
\end{definition}

While the formal definition of the Boolean Satisfiability Problem requires a
formula in propositional logic, expressing a \ac{sat} problem in propositional
logic can be cumbersome. Thus, modern satisfiability solvers programming
languages to express \ac{sat} problems, communicate the problems to other people
and dictate the problems to the solver. In recent years these programming
languages have coalesced into a single standard via an international initiative
called \acl{smtlib}.

The \acl{smtlib}~\cite{BarFT-SMTLIB} standard formalizes a set of programming
languages that define interactions with a \ac{sat} or \ac{smt} solver. The
standard defines four languages, of which only two are used throughout this
thesis: a \emph{term} language; which defines a language for defining variables,
functions and formulas in propositional and first-order logic. The
\emph{command} language; which defines a programming language to interact with
the solver. The command language is used to add or remove formulas, query the
solver for a model or check for satisfiability and other side-effectual
interactions such as printing output.

For the remainder of this section we provide informal examples intended for a
general audience and cover only the commands and concepts required for
subsequent sections of this thesis. For a full language specification please see
\citet{BarFT-SMTLIB}.

\todo{define a listing language for smtlib}Consider this \acl{smtlib} program
which verifies peirce's law implies the law of excluded middle for propositional
logic:
%
\begin{lstlisting}[columns=flexible,keepspaces=true,language=SMTLIB]
(declare-const a Bool)                       ;; variable declarations
(declare-const b Bool)
(define-fun ex-middle ((x Bool)) Bool        ;; excluded middle: $\color{Gray}x \vee \neg x$
  (or x
      (not x)))
(define-fun peirce ((x Bool) (y Bool)) Bool  ;; peirce's law: $\color{Gray}((x \rightarrow y) \rightarrow x) \rightarrow x$
  (=>
    (=> (=> x y)
        x)
    x))
(define-fun peirce-implies-ex-middle () Bool
  (=> (peirce a b)
      (ex-middle a)))
(assert (not peirce-implies-ex-middle))      ;; add assertion
(check-sat)                                  ;; check SAT of all assertions
\end{lstlisting}
%
Comments begin with a semi-colon (\rn{;}) and end at a new line. The program,
and every \acl{smtlib} program, is a sequence of \emph{commands} (called
\emph{statements} in the programming language literature) that interact with the
solver. For example, the above program consists of five commands, two variable
declarations, a function definition, an assertion and a command to check
satisfiability. Each command is formulated as an
\emph{s-expressions}~\cite{10.1145/367177.367199} to simplify parsing. For our
purposes, one only needs to understand that commands and functions are called by
opening parentheses; the first element after the opening parenthesis is the name
of the command or function symbol and every other element is an argument to that
command. Thus \lstinline{(declare-const a Bool)} is an s-expression with three
elements that defines the \pl{} variable \lstinline{a} of \emph{sort} (called
\emph{type} in programming language literature) \lstinline{Bool}. The first
element, \lstinline{declare-const} is the command name, the second is the user
defined name for the variable and the third is its sort. Similarly, the
s-expression \lstinline{(and a b)} passes the variables \lstinline{a} and
\lstinline{b} to the function \lstinline{and} which returns the conjunction of
these two variables. Lastly, the function definition \lstinline{define-fun}
takes four arguments: the user defined name; \lstinline{peirce-is-ex-middle}, an
s-expression that defines argument names and their sorts;
\lstinline{((x Bool) (y Bool))}, a return sort; \lstinline{Bool} and the body of
the function.

Internally, a compliant solver such as z3~\cite{10.1007/978-3-540-78800-3_24}
maintains an stack called the \emph{assertion stack} that tracks user provided
variable and formula declarations and definitions. The elements of the assertion
stack are called \emph{levels} and are sets of \emph{assertions}.
%
An assertion is a logical formula, a declaration of a sort, or a definition of a
function symbol. In the example, both variable declarations and the
\lstinline{peirce-is-ex-middle} definition are included in the assertion set.
Sets of assertions are placed on the stack via the \lstinline{assert} command.
The assert command takes a term as input\footnote{by the standard this is a
  \emph{well-sorted term} of type \emph{Bool}, however we elide this description
  for simplicity}, collects all associated definitions and declarations and
places the assertion set on the assertion stack.

The example demonstrates a common use pattern in \ac{sat} and \ac{smt} solving.
In the example we assert \lstinline{(not peirce-is-ex-middle)} rather than
\lstinline{peirce-is-ex-middle}. The \lstinline{not} is required due to the
relationship between satisfiability and logical validity; satisfiability
attempts to find a model that solves the constraints of a formula, while logical
validity tries to show that for any substitution of values into a formula the
formula will evaluate to true, that is, the formula's truth-value is independent
of its variables and thus it is tautological. Conceptually, where satisfiability
is concerned with solving constraints, validity is concerned with finding a
proof of a statement or formula. For the example, we query the solver to find a
model where \lstinline{peirce-is-ex-middle} theorem is \emph{not} true. If such
a model exists, then the model is an example of the \emph{negation} of the
theorem and thus a counter-example to the theorem. If no model exists---that is
\rn{unsat} is returned by the solver---then the negated theorem always evaluates
to \fls{} and thus the theorem always evaluates to \tru{} and hence is logically
valid.

%

%%% Local Variables:
%%% mode: latex
%%% TeX-master: "../../thesis"
%%% End:
