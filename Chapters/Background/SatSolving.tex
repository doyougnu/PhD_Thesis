~\label{section:sat-solving}

This section provides assumes knowledge of propositional logic, and provides
background to \acl{sat} and \ac{smtlib}; the standardized language for
interacting with \ac{sat} solvers. Following the notation from the many-valued
logic community~\cite{Rescher1969-RESML} we refer to propositional logic as
\pl{}, which denotes a two-valued logic.

A satisfiability solver is a software system that solves the Boolean
Satisfiability Problem. One of the oldest problems in computer
science\footnote{see~\citet{BBH+09} for a complete history from the ancients,
  through to George Boole to the modern day.} and famously
NP-complete~\cite{10.1145/800157.805047}, the Boolean satisfiability problem is
the problem of determining if a formula (sometimes called a sentence) in
propositional logic has an assignment of Boolean values to variables, such that
under substitution the formula evaluates to \tru{}. We formalize the problem and
terms in the following definitions:

\begin{definition}[Model]
  Given a formula in propositional logic: $\kf{f} \in \pl{}$, which contains a
  set of Boolean variables $\kf{vs}$. A model, $\kf{m}$, is a set of assignments
  of Boolean values to variables in $\kf{f}$ such that $\kf{f}$ evaluates to
  \tru{}, \ie{}, $\kf{m = \{ (v \assign b)\ |\ v \in vs, b \in \booleans} \}$.
\end{definition}

\begin{definition}[Satisfiable]
  \todo{add validity}Given a formula in propositional logic, $\kf{f}$, which
  contains a set of Boolean variables $vs$. If there exists an assignment of
  variables to Boolean values such that $\kf{f}$ evaluates to \tru{}, then we
  say $\kf{f}$ is \emph{satisfiable}.
\end{definition}

For example, we can show that the formula $\kf{good = (a \wedge b) \vee c}$ is
satisfiable with the model: $\{\kf{(a \assign{} \tru{}), (b \assign{} \tru{}),
  (c \assign{} \fls{})}\}$, because $(\tru{} \wedge{} \tru{}) \vee{} \fls{}$
results in \tru{}. However, a formula such as $\kf{bad = (a \vee b) \wedge
  \fls{}}$ is not satisfiable as no assignment of \fls{} or \tru{} to the
variables $\kf{a}$ and $\kf{b}$ would allow $\kf{bad}$ to evaluate to \tru{}.
With the preliminaries concepts we can now define the Boolean Satisfiability
Problem:

\begin{definition}[Boolean Satisfiability Problem]
  Given a formula in propositional logic, $\kf{f}$, determine if $\kf{f}$ is
  satisfiable.
\end{definition}

While the formal definition of the Boolean Satisfiability Problem requires a
formula in propositional logic, expressing the \ac{sat} problem in propositional
logic can be cumbersome. Thus, modern satisfiability solvers programming
languages to express \ac{sat} problems, communicate the problems to other people
and dictate the problems to the solver. In recent years these programming
languages have coalesced into a single standard via an international initiative
called \acl{smtlib}.

The \acl{smtlib}~\cite{BarFT-SMTLIB} standard formalizes a set of programming
languages that define interactions with a \ac{sat} or \ac{smt} solver. The
standard defines four languages, of which only two are used throughout this
thesis: a \emph{term} language; which defines a language for defining variables,
functions and formulas in propositional and first-order logic. The
\emph{command} language; which defines a programming language to interact with
the solver. The command language is used to add or remove formulas, query the
solver for a model or check for satisfiability and other side-effectual
interactions such as printing output.

For the remainder of this section we provide informal examples intended for a
general audience and cover only the commands and concepts required for
subsequent sections of this thesis. For a full language specification please see
\citet{BarFT-SMTLIB}.

\todo{define a listing language for smtlib}Consider this \acl{smtlib} program
which verifies that demorgans' law holds:
%
\begin{lstlisting}[columns=flexible,keepspaces=true,language=SMTLIB]
  (declare-const a Bool)        ;; variable declarations
  (declare-const b Bool)
  (define-fun demorgan () Bool  ;; define demorgans
    (= (and a b) (not (or (not a) (not b)))))
  (assert (not demorgan))       ;; add an assertion for not demorgans
  (check-sat)                   ;; check the satisfiability of assertions
\end{lstlisting}
%
The program, and every \acl{smtlib} program, is a sequence of \emph{commands}
(called \emph{statements} in the programming language literature) that interact
with the solver. For example, the above program consists of five commands, two
variable declarations, a function definition, an assertion and a command to
check satisfiability. Each command is formulated as an
\emph{s-expressions}~\cite{10.1145/367177.367199} to simplify parsing. For our
purposes, one only needs to understand that commands and functions are called by
opening parentheses; the first element after the opening parenthesis is the name
of the command or function symbol and every other element is an argument to that
command. Thus \lstinline{(declare-const a Bool)} is an s-expression with three
elements that defines the \pl{} variable \lstinline{a} of \emph{sort} (called
\emph{type} in programming language literature) \lstinline{Bool}. The first
element, \lstinline{declare-const} is the command name, the second is the user
defined name for the variable and the third is its sort. Similarly, the
s-expression \lstinline{(and a b)} passes the variables \lstinline{a} and
\lstinline{b} to the function \lstinline{and} which returns the conjunction of
these two variables.

Internally, a compliant solver such as z3~\cite{10.1007/978-3-540-78800-3_24}
maintains an stack called the \emph{assertion stack} that tracks user provided
variable and formula declarations and definitions. The elements of the assertion
stack are called \emph{levels} and are sets of \emph{assertions}.
%
An assertion is a logical formula, a declaration of a sort, or a definition of a
function symbol. In the example, both variable declarations and the
\lstinline{demorgan} definition are included in the assertion set. Sets of
assertions are placed on the stack via the \lstinline{assert} command. The
assert command takes a formula as input\footnote{by the standard this the
  formula is actually a \emph{well-sorted term} of type \emph{Bool}, however we
  elide this description for simplicity}, collects all associated definitions
and declarations and places the assertion set on the assertion stack.

Notice that the example asserts \lstinline{not demorgan} rather than
\lstinline{demorgan}. This is due to the relationship between satisfiability and
logical validity; satisfiability attempts to find a model that solves the
constraints of a formula, while logical validity tries to show that for any
substitution of values into a formula the formula will evaluate to true. Thus
where satisfiability is concerned with solving constraints, validity is
concerned with finding a proof of a statement or formula. hence, for the example
we query the solver to find a model where demorgans' theorem is \emph{not} true.
If such a model exists then it is a counter-example to the theorem, if no model
exists then we can be sure that for all values of type Bool demorgans' theorem
will hold.

%

%%% Local Variables:
%%% mode: latex
%%% TeX-master: "../../thesis"
%%% End:
