\label{section:conclusion:applications}
%
Variational \ac{sat} and \ac{smt} solving provides an improved user interface
and possible performance gains for variational \ac{sat} and \ac{smt} problems.
However, the space of variational \ac{sat} and \ac{smt} problems is largely
unexplored, as viewing problems as inherently \emph{variational} is only just
beginning to gain awareness outside of the software product-line and variational
programming languages communities. In this section we describe areas for
possible applications.

\citet{TTS+:VariVolution19} define two fundamental dimensions of variation:
variation in \emph{time}, where software is revised over some unit of time with
the intent that the new version will replace the old version; and variation in
\emph{space} where variants are meant to co-exist simultaneously. Our approach
to variational \ac{sat} and \ac{smt} solving is able to express both kinds of
variation with the caveat that all points of variation are known \emph{before}
running the solver. Thus, applications that utilize a plain \ac{sat} solver, do
not need to discover variation during run-time and that must negotiate variation
in time or space are possible applications for variational \ac{sat} or \ac{smt}
solver.

Problems in this domain include scheduling problems~\cite{BBH+09} which need to
account for a counterfactual event; for example, scheduling a set of jobs on a
number of machines but also accounting for one or several machines being unable
to take jobs. Such a problem is directly expressible in \ac{vpl} where each
dimensions corresponds to a machine being online, or a machine being disabled.
Another classic \ac{sat} application is circuit layout and hardware verification
problems~\cite{BBH+09}. In this domain, \ac{sat} solvers are used as the
back-end engine to answer safety and live-ness questions; questions such as a
given system can never reach a certain state or a system will always reach some
given state after a certain state is reached~\cite{BBH+09}. This work could be
directly applied to such problems; for example one might have two or more
circuits which share significant regions and yet are distinct products with
distinct behavior. Performing hardware verification on each circuit would
produce two related \ac{sat} problems, where the shared portions are redundantly
calculated. Thus, one can imagine translating the set of \ac{sat} problems to a
\ac{vpl} formula and solving them with a variational solver. Another direct
application would be performing hardware verification in the presence of
patches, one might encode speculative analyses to ensure desirable properties in
the hardware if regions or elements in the circuit are completely removed,
significantly patched, or stop operating. The particulars in this domain are
open research questions, however given the findings in this thesis large
performance gains are possible through the use of a variational \ac{sat} or
\ac{smt} solvers.

%
Software variability is a natural application domain for this work. The
variability of SPLs or configurable software is often reduced to propositional
logic~\citep{B05,CW07,MWCC08} for analysis
purposes~\citep{BSRC10,TAK+:CSUR14,GBT+19}. Many analyses have been implemented
using \ac{sat} solving such as~\cite{TAK+:CSUR14}, including feature-model
analysis~\citep{BSRC10,GBT+19}, parsing~\citep{KGR+:OOPSLA11}, dead-code
analysis~\citep{TLSS:EuroSys11}, code simplification~\citep{RGA+:ICSE15}, type
checking~\citep{TBKC07}, consistency checking~\citep{CP06}, dataflow
analysis~\citep{LKA+:ESECFSE13}, model checking~\citep{CCS+13},
variability-aware execution~\citep{NKN:ICSE14}, testing~\citep{MMCA:IST14},
product sampling~\citep{MKR+:ICSE16,VAT+:SPLC18}, product
configuration~\citep{SIMA:ASE13}, optimization of non-functional
properties~\citep{SRK+:SQJ12}, and variant-preserving
refactoring~\citep{FMS+:SANER17}. While each of these analyses gives rise to
multiple \ac{sat} problems for even a single analysis run, the authors typically
do not discuss how they are solved. We argue that many could benefit from
variational solving.

More generally, any scenario that involves solving many related \ac{sat}
problems, and where all of these problems are known or can be generated in
advance, is a potential application for variational \ac{sat} solving.
%
Such situations arise in program analysis~\citep{VGD:FSE12}, and especially in
\emph{speculative} program analyses that involve generating and exploring huge
numbers of variations of a program, for example, as in
counterfactual~\citep{CE14popl} and migrational~\citep{CCW18icfp,CCEW18popl}
typing. Furthermore, we believe that variational solving could provide a basis
for similar speculative analyses on feature models.


%%% Local Variables:
%%% mode: latex
%%% TeX-master: "../../thesis"
%%% End: